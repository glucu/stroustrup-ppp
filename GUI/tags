!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FIELD_DESCRIPTION!C++	name	/aliased names/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!C++	c,class	/classes/
!_TAG_KIND_DESCRIPTION!C++	d,macro	/macro definitions/
!_TAG_KIND_DESCRIPTION!C++	e,enumerator	/enumerators (values inside an enumeration)/
!_TAG_KIND_DESCRIPTION!C++	f,function	/function definitions/
!_TAG_KIND_DESCRIPTION!C++	g,enum	/enumeration names/
!_TAG_KIND_DESCRIPTION!C++	h,header	/included header files/
!_TAG_KIND_DESCRIPTION!C++	m,member	/class, struct, and union members/
!_TAG_KIND_DESCRIPTION!C++	n,namespace	/namespaces/
!_TAG_KIND_DESCRIPTION!C++	s,struct	/structure names/
!_TAG_KIND_DESCRIPTION!C++	t,typedef	/typedefs/
!_TAG_KIND_DESCRIPTION!C++	u,union	/union names/
!_TAG_KIND_DESCRIPTION!C++	v,variable	/variable definitions/
!_TAG_KIND_DESCRIPTION!Sh	a,alias	/aliases/
!_TAG_KIND_DESCRIPTION!Sh	f,function	/functions/
!_TAG_KIND_DESCRIPTION!Sh	h,heredoc	/label for here document/
!_TAG_KIND_DESCRIPTION!Sh	s,script	/script files/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	0.0	/current.age/
!_TAG_PARSER_VERSION!C++	0.0	/current.age/
!_TAG_PARSER_VERSION!Sh	0.0	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/glucu/dev/programming-principles-and-practice-using-cpp/GUI/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.0.0	/a4d751bc/
!_TAG_ROLE_DESCRIPTION!C++!header	local	/local header/
!_TAG_ROLE_DESCRIPTION!C++!header	system	/system header/
!_TAG_ROLE_DESCRIPTION!C++!macro	undef	/undefined/
!_TAG_ROLE_DESCRIPTION!Sh!heredoc	endmarker	/end marker/
!_TAG_ROLE_DESCRIPTION!Sh!script	loaded	/loaded/
Address	GUI.h	/^typedef void* Address;$/;"	t	namespace:Graph_lib	typeref:typename:void *
Axis	Graph.cpp	/^Axis::Axis(Orientation d, Point xy, int length, int n, string lab)$/;"	f	class:Graph_lib::Axis
Axis	Graph.h	/^struct Axis : Shape {$/;"	s	namespace:Graph_lib
Bad_image	Graph.h	/^	Bad_image(int h, int w) : Fl_Image(h,w,0) { }$/;"	f	struct:Graph_lib::Bad_image
Bad_image	Graph.h	/^struct Bad_image : Fl_Image {$/;"	s	namespace:Graph_lib
Button	GUI.h	/^	Button(Point xy, int ww, int hh, const string& s, Callback cb)$/;"	f	class:Graph_lib::Button
Button	GUI.h	/^class Button : public Widget {$/;"	c	namespace:Graph_lib
Callback	GUI.h	/^using Callback = function<void(Address)>;    \/\/ FLTK's required function type for all callback/;"	t	namespace:Graph_lib
Circle	Graph.h	/^	Circle(Point p, int rr)	\/\/ center and radius$/;"	f	struct:Graph_lib::Circle
Circle	Graph.h	/^struct Circle : Shape {$/;"	s	namespace:Graph_lib
Closed_polyline	Graph.h	/^struct Closed_polyline : Open_polyline {	\/\/ closed sequence of lines$/;"	s	namespace:Graph_lib
Color	Graph.h	/^	Color(Color_type cc) :c(Fl_Color(cc)), v(visible) { }$/;"	f	struct:Graph_lib::Color
Color	Graph.h	/^	Color(Color_type cc, Transparency vv) :c(Fl_Color(cc)), v(vv) { }$/;"	f	struct:Graph_lib::Color
Color	Graph.h	/^	Color(Transparency vv) :c(Fl_Color()), v(vv) { }$/;"	f	struct:Graph_lib::Color
Color	Graph.h	/^	Color(int cc) :c(Fl_Color(cc)), v(visible) { }$/;"	f	struct:Graph_lib::Color
Color	Graph.h	/^struct Color {$/;"	s	namespace:Graph_lib
Color_type	Graph.h	/^	enum Color_type {$/;"	g	struct:Graph_lib::Color
Ellipse	Graph.h	/^	Ellipse(Point p, int ww, int hh)	\/\/ center, max, and min distance from center$/;"	f	struct:Graph_lib::Ellipse
Ellipse	Graph.h	/^struct Ellipse : Shape {$/;"	s	namespace:Graph_lib
Encoding	Graph.h	/^	enum Encoding { none, jpg, gif, bmp, png};$/;"	g	struct:Graph_lib::Suffix
FLTK_GUARD	fltk.h	/^#define FLTK_GUARD /;"	d
Fct	Graph.h	/^using Fct = double (*)(double);$/;"	t	namespace:Graph_lib
Fill	Graph.h	/^	Fill() :no_fill(true), fcolor(0) { }$/;"	f	struct:Graph_lib::Fill
Fill	Graph.h	/^	Fill(Color c) :no_fill(false), fcolor(c) { }$/;"	f	struct:Graph_lib::Fill
Fill	Graph.h	/^struct Fill {$/;"	s	namespace:Graph_lib
Font	Graph.h	/^	Font(Font_type ff) :f(ff) { }$/;"	f	class:Graph_lib::Font
Font	Graph.h	/^	Font(int ff) :f(ff) { }$/;"	f	class:Graph_lib::Font
Font	Graph.h	/^class Font {$/;"	c	namespace:Graph_lib
Font_type	Graph.h	/^	enum Font_type {$/;"	g	class:Graph_lib::Font
Function	Graph.cpp	/^Function::Function(Fct f, double r1, double r2, Point xy, int count, double xscale, double yscal/;"	f	class:Graph_lib::Function
Function	Graph.h	/^struct Function : Shape {$/;"	s	namespace:Graph_lib
GRAPH_GUARD	Graph.h	/^#define GRAPH_GUARD /;"	d
GUI_GUARD	GUI.h	/^#define GUI_GUARD$/;"	d
Graph_lib	GUI.h	/^namespace Graph_lib {$/;"	n
Graph_lib	Graph.cpp	/^namespace Graph_lib {$/;"	n	file:
Graph_lib	Graph.h	/^namespace Graph_lib {$/;"	n
Graph_lib	Point.h	/^namespace Graph_lib {$/;"	n
Graph_lib	Window.cpp	/^namespace Graph_lib {$/;"	n	file:
Graph_lib	Window.h	/^namespace Graph_lib {$/;"	n
Image	Graph.cpp	/^Image::Image(Point xy, string s, Suffix::Encoding e)$/;"	f	class:Graph_lib::Image
Image	Graph.h	/^struct Image : Shape {$/;"	s	namespace:Graph_lib
In_box	GUI.h	/^	In_box(Point xy, int w, int h, const string& s)$/;"	f	struct:Graph_lib::In_box
In_box	GUI.h	/^struct In_box : Widget {$/;"	s	namespace:Graph_lib
Kind	GUI.h	/^	enum Kind { horizontal, vertical };$/;"	g	struct:Graph_lib::Menu
Line	Graph.h	/^	Line(Point p1, Point p2) { add(p1); add(p2); }$/;"	f	struct:Graph_lib::Line
Line	Graph.h	/^struct Line : Shape {$/;"	s	namespace:Graph_lib
Line_style	Graph.h	/^	Line_style(Line_style_type lst, int ww) :s(lst), w(ww) { }$/;"	f	struct:Graph_lib::Line_style
Line_style	Graph.h	/^	Line_style(Line_style_type ss) :s(ss), w(0) { }$/;"	f	struct:Graph_lib::Line_style
Line_style	Graph.h	/^	Line_style(int ss) :s(ss), w(0) { }$/;"	f	struct:Graph_lib::Line_style
Line_style	Graph.h	/^struct Line_style {$/;"	s	namespace:Graph_lib
Line_style_type	Graph.h	/^	enum Line_style_type {$/;"	g	struct:Graph_lib::Line_style
Lines	Graph.h	/^	Lines() {}$/;"	f	struct:Graph_lib::Lines
Lines	Graph.h	/^	Lines(initializer_list<Point> lst) : Shape{lst} { if (lst.size() % 2) error("odd number of poin/;"	f	struct:Graph_lib::Lines
Lines	Graph.h	/^struct Lines : Shape {	\/\/ indepentdent lines$/;"	s	namespace:Graph_lib
Mark	Graph.h	/^	Mark(Point xy, char c) : Marks(string(1,c)) {add(xy); }$/;"	f	struct:Graph_lib::Mark
Mark	Graph.h	/^struct Mark : Marks {$/;"	s	namespace:Graph_lib
Marked_polyline	Graph.h	/^	Marked_polyline(const string& m) :mark(m) { }$/;"	f	struct:Graph_lib::Marked_polyline
Marked_polyline	Graph.h	/^struct Marked_polyline : Open_polyline {$/;"	s	namespace:Graph_lib
Marks	Graph.h	/^	Marks(const string& m) :Marked_polyline(m)$/;"	f	struct:Graph_lib::Marks
Marks	Graph.h	/^struct Marks : Marked_polyline {$/;"	s	namespace:Graph_lib
Menu	GUI.cpp	/^Menu::Menu(Point xy, int w, int h, Kind kk, const string& s)$/;"	f	class:Menu
Menu	GUI.h	/^struct Menu : Widget {$/;"	s	namespace:Graph_lib
Open_polyline	Graph.h	/^struct Open_polyline : Shape {	\/\/ open sequence of lines$/;"	s	namespace:Graph_lib
Orientation	Graph.h	/^	enum Orientation { x, y, z };$/;"	g	struct:Graph_lib::Axis
Out_box	GUI.h	/^	Out_box(Point xy, int w, int h, const string& s\/*, Window& win*\/)$/;"	f	struct:Graph_lib::Out_box
Out_box	GUI.h	/^struct Out_box : Widget {$/;"	s	namespace:Graph_lib
POINT_GUARD	Point.h	/^#define POINT_GUARD$/;"	d
Point	Point.h	/^	Point() :x(0), y(0) { }$/;"	f	struct:Graph_lib::Point
Point	Point.h	/^	Point(int xx, int yy) : x(xx), y(yy) { }$/;"	f	struct:Graph_lib::Point
Point	Point.h	/^struct Point {$/;"	s	namespace:Graph_lib
Polygon	Graph.h	/^struct Polygon : Closed_polyline {	\/\/ closed sequence of non-intersecting lines$/;"	s	namespace:Graph_lib
Rectangle	Graph.h	/^	Rectangle(Point x, Point y) :w{ y.x - x.x }, h{ y.y - x.y }$/;"	f	struct:Graph_lib::Rectangle
Rectangle	Graph.h	/^	Rectangle(Point xy, int ww, int hh) :w{ ww }, h{ hh }$/;"	f	struct:Graph_lib::Rectangle
Rectangle	Graph.h	/^struct Rectangle : Shape {$/;"	s	namespace:Graph_lib
Shape	Graph.h	/^	Shape() { }$/;"	f	class:Graph_lib::Shape
Shape	Graph.h	/^	Shape(initializer_list<Point> lst) { for(Point p : lst) add(p); }  \/\/ add() the Points to thi/;"	f	class:Graph_lib::Shape
Shape	Graph.h	/^class Shape  {	\/\/ deals with color and style, and holds sequence of lines$/;"	c	namespace:Graph_lib
Simple_window	Simple_window.cpp	/^Simple_window::Simple_window(Point xy, int w, int h, const string& title) :$/;"	f	class:Simple_window
Simple_window	Simple_window.h	/^struct Simple_window : Graph_lib::Window {$/;"	s
Suffix	Graph.h	/^struct Suffix {$/;"	s	namespace:Graph_lib
Text	Graph.h	/^	Text(Point x, const string& s) : lab{ s } { add(x); }$/;"	f	struct:Graph_lib::Text
Text	Graph.h	/^struct Text : Shape {$/;"	s	namespace:Graph_lib
Transparency	Graph.h	/^	enum Transparency { invisible = 0, visible=255 };$/;"	g	struct:Graph_lib::Color
Vector_ref	Graph.h	/^	Vector_ref() {}$/;"	f	class:Graph_lib::Vector_ref
Vector_ref	Graph.h	/^	Vector_ref(T* a, T* b=0, T* c=0, T* d=0)$/;"	f	class:Graph_lib::Vector_ref
Vector_ref	Graph.h	/^template<class T> class Vector_ref {$/;"	c	namespace:Graph_lib
WINDOW_GUARD	Window.h	/^#define WINDOW_GUARD /;"	d
Widget	GUI.h	/^	Widget(Point xy, int w, int h, const string& s, Callback cb)$/;"	f	class:Graph_lib::Widget
Widget	GUI.h	/^class Widget {$/;"	c	namespace:Graph_lib
Window	Window.cpp	/^Window::Window(Point xy, int ww, int hh, const string& title)$/;"	f	class:Graph_lib::Window
Window	Window.cpp	/^Window::Window(int ww, int hh, const string& title)$/;"	f	class:Graph_lib::Window
Window	Window.h	/^class Window : public Fl_Window { $/;"	c	namespace:Graph_lib
add	Graph.cpp	/^void Polygon::add(Point p)$/;"	f	class:Graph_lib::Polygon	typeref:typename:void
add	Graph.h	/^	void add(Point p) { Shape::add(p); }$/;"	f	struct:Graph_lib::Open_polyline	typeref:typename:void
add	Graph.h	/^	void add(Point p){ points.push_back(p); }$/;"	f	class:Graph_lib::Shape	typeref:typename:void
add	Graph.h	/^	void add(Point p1, Point p2) { Shape::add(p1); Shape::add(p2); }$/;"	f	struct:Graph_lib::Lines	typeref:typename:void
as_int	Graph.h	/^	int as_int() const { return c; }$/;"	f	struct:Graph_lib::Color	typeref:typename:int
as_int	Graph.h	/^	int as_int() const { return f; }$/;"	f	class:Graph_lib::Font	typeref:typename:int
attach	GUI.cpp	/^int Menu::attach(Button& b)$/;"	f	class:Menu	typeref:typename:int
attach	GUI.cpp	/^int Menu::attach(Button* p)$/;"	f	class:Menu	typeref:typename:int
attach	GUI.cpp	/^void Button::attach(Window& win)$/;"	f	class:Button	typeref:typename:void
attach	GUI.cpp	/^void In_box::attach(Window& win)$/;"	f	class:In_box	typeref:typename:void
attach	GUI.cpp	/^void Out_box::attach(Window& win)$/;"	f	class:Out_box	typeref:typename:void
attach	GUI.h	/^	void attach(Window& win)$/;"	f	struct:Graph_lib::Menu	typeref:typename:void
attach	Window.cpp	/^void Window::attach(Shape& s)$/;"	f	class:Graph_lib::Window	typeref:typename:void
attach	Window.cpp	/^void Window::attach(Widget& w)$/;"	f	class:Graph_lib::Window	typeref:typename:void
black	Graph.h	/^		yellow=FL_YELLOW, white=FL_WHITE, black=FL_BLACK,$/;"	e	enum:Graph_lib::Color::Color_type
blue	Graph.h	/^		red=FL_RED, blue=FL_BLUE, green=FL_GREEN,$/;"	e	enum:Graph_lib::Color::Color_type
bmp	Graph.h	/^	enum Encoding { none, jpg, gif, bmp, png};$/;"	e	enum:Graph_lib::Suffix::Encoding
button_pushed	Simple_window.h	/^	bool button_pushed;$/;"	m	struct:Simple_window	typeref:typename:bool
c	Graph.h	/^	Fl_Color c;$/;"	m	struct:Graph_lib::Color	typeref:typename:Fl_Color
can_open	Graph.cpp	/^bool can_open(const string& s)$/;"	f	namespace:Graph_lib	typeref:typename:bool
cb_next	Simple_window.cpp	/^void Simple_window::cb_next(Address, Address pw)$/;"	f	class:Simple_window	typeref:typename:void
center	Graph.h	/^	Point center() const { return { point(0).x + r, point(0).y + r }; }$/;"	f	struct:Graph_lib::Circle	typeref:typename:Point
center	Graph.h	/^	Point center() const { return{ point(0).x + w, point(0).y + h }; }$/;"	f	struct:Graph_lib::Ellipse	typeref:typename:Point
color	Graph.h	/^	Color color() const { return lcolor; }$/;"	f	class:Graph_lib::Shape	typeref:typename:Color
courier	Graph.h	/^		courier=FL_COURIER,$/;"	e	enum:Graph_lib::Font::Font_type
courier_bold	Graph.h	/^  		courier_bold=FL_COURIER_BOLD,$/;"	e	enum:Graph_lib::Font::Font_type
courier_bold_italic	Graph.h	/^  		courier_bold_italic=FL_COURIER_BOLD_ITALIC,$/;"	e	enum:Graph_lib::Font::Font_type
courier_italic	Graph.h	/^  		courier_italic=FL_COURIER_ITALIC,$/;"	e	enum:Graph_lib::Font::Font_type
cx	Graph.h	/^	int w,h,cx,cy; \/\/ define "masking box" within image relative to position (cx,cy)$/;"	m	struct:Graph_lib::Image	typeref:typename:int
cy	Graph.h	/^	int w,h,cx,cy; \/\/ define "masking box" within image relative to position (cx,cy)$/;"	m	struct:Graph_lib::Image	typeref:typename:int
cyan	Graph.h	/^		magenta=FL_MAGENTA, cyan=FL_CYAN, dark_red=FL_DARK_RED,$/;"	e	enum:Graph_lib::Color::Color_type
dark_blue	Graph.h	/^		dark_green=FL_DARK_GREEN, dark_yellow=FL_DARK_YELLOW, dark_blue=FL_DARK_BLUE,$/;"	e	enum:Graph_lib::Color::Color_type
dark_cyan	Graph.h	/^		dark_magenta=FL_DARK_MAGENTA, dark_cyan=FL_DARK_CYAN$/;"	e	enum:Graph_lib::Color::Color_type
dark_green	Graph.h	/^		dark_green=FL_DARK_GREEN, dark_yellow=FL_DARK_YELLOW, dark_blue=FL_DARK_BLUE,$/;"	e	enum:Graph_lib::Color::Color_type
dark_magenta	Graph.h	/^		dark_magenta=FL_DARK_MAGENTA, dark_cyan=FL_DARK_CYAN$/;"	e	enum:Graph_lib::Color::Color_type
dark_red	Graph.h	/^		magenta=FL_MAGENTA, cyan=FL_CYAN, dark_red=FL_DARK_RED,$/;"	e	enum:Graph_lib::Color::Color_type
dark_yellow	Graph.h	/^		dark_green=FL_DARK_GREEN, dark_yellow=FL_DARK_YELLOW, dark_blue=FL_DARK_BLUE,$/;"	e	enum:Graph_lib::Color::Color_type
dash	Graph.h	/^		dash=FL_DASH,				\/\/ - - - -$/;"	e	enum:Graph_lib::Line_style::Line_style_type
dashdot	Graph.h	/^		dashdot=FL_DASHDOT,			\/\/ - . - . $/;"	e	enum:Graph_lib::Line_style::Line_style_type
dashdotdot	Graph.h	/^		dashdotdot=FL_DASHDOTDOT,	\/\/ -..-..$/;"	e	enum:Graph_lib::Line_style::Line_style_type
detach	Window.cpp	/^void Window::detach(Shape& s)$/;"	f	class:Graph_lib::Window	typeref:typename:void
detach	Window.cpp	/^void Window::detach(Widget& b)$/;"	f	class:Graph_lib::Window	typeref:typename:void
do_it	GUI.h	/^	Callback do_it;$/;"	m	class:Graph_lib::Widget	typeref:typename:Callback
dot	Graph.h	/^		dot=FL_DOT,					\/\/ ....... $/;"	e	enum:Graph_lib::Line_style::Line_style_type
draw	Graph.cpp	/^void Shape::draw() const$/;"	f	class:Graph_lib::Shape	typeref:typename:void
draw	Graph.h	/^	void draw(int x,int y, int, int, int, int) { draw_empty(x,y); }$/;"	f	struct:Graph_lib::Bad_image	typeref:typename:void
draw	Window.cpp	/^void Window::draw()$/;"	f	class:Graph_lib::Window	typeref:typename:void
draw_lines	Graph.cpp	/^void Axis::draw_lines() const$/;"	f	class:Graph_lib::Axis	typeref:typename:void
draw_lines	Graph.cpp	/^void Circle::draw_lines() const$/;"	f	class:Graph_lib::Circle	typeref:typename:void
draw_lines	Graph.cpp	/^void Closed_polyline::draw_lines() const$/;"	f	class:Graph_lib::Closed_polyline	typeref:typename:void
draw_lines	Graph.cpp	/^void Ellipse::draw_lines() const$/;"	f	class:Graph_lib::Ellipse	typeref:typename:void
draw_lines	Graph.cpp	/^void Image::draw_lines() const$/;"	f	class:Graph_lib::Image	typeref:typename:void
draw_lines	Graph.cpp	/^void Lines::draw_lines() const$/;"	f	class:Graph_lib::Lines	typeref:typename:void
draw_lines	Graph.cpp	/^void Marked_polyline::draw_lines() const$/;"	f	class:Graph_lib::Marked_polyline	typeref:typename:void
draw_lines	Graph.cpp	/^void Open_polyline::draw_lines() const$/;"	f	class:Graph_lib::Open_polyline	typeref:typename:void
draw_lines	Graph.cpp	/^void Polygon::draw_lines() const$/;"	f	class:Graph_lib::Polygon	typeref:typename:void
draw_lines	Graph.cpp	/^void Rectangle::draw_lines() const$/;"	f	class:Graph_lib::Rectangle	typeref:typename:void
draw_lines	Graph.cpp	/^void Shape::draw_lines() const$/;"	f	class:Graph_lib::Shape	typeref:typename:void
draw_lines	Graph.cpp	/^void Text::draw_lines() const$/;"	f	class:Graph_lib::Text	typeref:typename:void
draw_mark	Graph.cpp	/^void draw_mark(Point xy, char c)$/;"	f	namespace:Graph_lib	typeref:typename:void
f	Graph.h	/^	int f;$/;"	m	class:Graph_lib::Font	typeref:typename:int
fcolor	Graph.h	/^	Color fcolor {Color::invisible};$/;"	m	class:Graph_lib::Shape	typeref:typename:Color
fcolor	Graph.h	/^	Color fcolor;$/;"	m	struct:Graph_lib::Fill	typeref:typename:Color
fill_color	Graph.h	/^	Color fill_color() const { return fcolor; }$/;"	f	class:Graph_lib::Shape	typeref:typename:Color
fill_color	Graph.h	/^	Color fill_color() { return fcolor; }$/;"	f	struct:Graph_lib::Fill	typeref:typename:Color
fn	Graph.h	/^	Text fn;$/;"	m	struct:Graph_lib::Image	typeref:typename:Text
fnt	Graph.h	/^	Font fnt{ fl_font() };$/;"	m	struct:Graph_lib::Text	typeref:typename:Font
fnt_sz	Graph.h	/^	int fnt_sz{ (14<fl_size()) ? fl_size() : 14 };	\/\/ at least 14 point$/;"	m	struct:Graph_lib::Text	typeref:typename:int
focus1	Graph.h	/^	Point focus1() const { return{ center().x + int(sqrt(double(w*w - h*h))), center().y }; }$/;"	f	struct:Graph_lib::Ellipse	typeref:typename:Point
focus2	Graph.h	/^	Point focus2() const { return{ center().x - int(sqrt(double(w*w - h*h))), center().y }; }$/;"	f	struct:Graph_lib::Ellipse	typeref:typename:Point
font	Graph.h	/^	Font font() const { return Font(fnt); }$/;"	f	struct:Graph_lib::Text	typeref:typename:Font
font_size	Graph.h	/^	int font_size() const { return fnt_sz; }$/;"	f	struct:Graph_lib::Text	typeref:typename:int
get_encoding	Graph.cpp	/^Suffix::Encoding get_encoding(const string& s)$/;"	f	namespace:Graph_lib	typeref:typename:Suffix::Encoding
get_int	GUI.cpp	/^int In_box::get_int()$/;"	f	class:In_box	typeref:typename:int
get_string	GUI.cpp	/^string In_box::get_string()$/;"	f	class:In_box	typeref:typename:string
gif	Graph.h	/^	enum Encoding { none, jpg, gif, bmp, png};$/;"	e	enum:Graph_lib::Suffix::Encoding
green	Graph.h	/^		red=FL_RED, blue=FL_BLUE, green=FL_GREEN,$/;"	e	enum:Graph_lib::Color::Color_type
gui_main	Window.cpp	/^int gui_main() { return Fl::run(); }$/;"	f	namespace:Graph_lib	typeref:typename:int
h	Graph.h	/^	int h;			\/\/ height$/;"	m	struct:Graph_lib::Rectangle	typeref:typename:int
h	Graph.h	/^	int h;$/;"	m	struct:Graph_lib::Ellipse	typeref:typename:int
h	Graph.h	/^	int w,h,cx,cy; \/\/ define "masking box" within image relative to position (cx,cy)$/;"	m	struct:Graph_lib::Image	typeref:typename:int
h	Window.h	/^	  int w,h;					\/\/ window size$/;"	m	class:Graph_lib::Window	typeref:typename:int
height	GUI.h	/^	int height;$/;"	m	class:Graph_lib::Widget	typeref:typename:int
height	Graph.h	/^	int height() const { return h; }$/;"	f	struct:Graph_lib::Rectangle	typeref:typename:int
helvetica	Graph.h	/^		helvetica=FL_HELVETICA,$/;"	e	enum:Graph_lib::Font::Font_type
helvetica_bold	Graph.h	/^		helvetica_bold=FL_HELVETICA_BOLD,$/;"	e	enum:Graph_lib::Font::Font_type
helvetica_bold_italic	Graph.h	/^		helvetica_bold_italic=FL_HELVETICA_BOLD_ITALIC,$/;"	e	enum:Graph_lib::Font::Font_type
helvetica_italic	Graph.h	/^		helvetica_italic=FL_HELVETICA_ITALIC,$/;"	e	enum:Graph_lib::Font::Font_type
hide	GUI.h	/^	virtual void hide() { pw->hide(); }$/;"	f	class:Graph_lib::Widget	typeref:typename:void
hide	GUI.h	/^	void hide() { for (int i = 0; i<selection.size(); ++i) selection[i].hide(); }$/;"	f	struct:Graph_lib::Menu	typeref:typename:void
horizontal	GUI.h	/^	enum Kind { horizontal, vertical };$/;"	e	enum:Graph_lib::Menu::Kind
init	Window.cpp	/^void Window::init()$/;"	f	class:Graph_lib::Window	typeref:typename:void
init_suffix_map	Graph.cpp	/^int init_suffix_map()$/;"	f	namespace:Graph_lib	typeref:typename:int
invisible	Graph.h	/^	enum Transparency { invisible = 0, visible=255 };$/;"	e	enum:Graph_lib::Color::Transparency
jpg	Graph.h	/^	enum Encoding { none, jpg, gif, bmp, png};$/;"	e	enum:Graph_lib::Suffix::Encoding
k	GUI.h	/^	Kind k;$/;"	m	struct:Graph_lib::Menu	typeref:typename:Kind
lab	Graph.h	/^	string lab;	\/\/ label$/;"	m	struct:Graph_lib::Text	typeref:typename:string
label	GUI.h	/^	string label;$/;"	m	class:Graph_lib::Widget	typeref:typename:string
label	Graph.h	/^	Text label;$/;"	m	struct:Graph_lib::Axis	typeref:typename:Text
label	Graph.h	/^	string label() const { return lab; }$/;"	f	struct:Graph_lib::Text	typeref:typename:string
lcolor	Graph.h	/^	Color lcolor {int(fl_color())}; \/\/ cast was used to supress narrowing warning$/;"	m	class:Graph_lib::Shape	typeref:typename:Color
line_intersect	Graph.cpp	/^inline pair<double,double> line_intersect(Point p1, Point p2, Point p3, Point p4, bool& parallel/;"	f	namespace:Graph_lib	typeref:typename:pair<double,double>
line_segment_intersect	Graph.cpp	/^bool line_segment_intersect(Point p1, Point p2, Point p3, Point p4, Point& intersection){$/;"	f	namespace:Graph_lib	typeref:typename:bool
loc	GUI.h	/^	Point loc;$/;"	m	class:Graph_lib::Widget	typeref:typename:Point
ls	Graph.h	/^	Line_style ls {0};$/;"	m	class:Graph_lib::Shape	typeref:typename:Line_style
magenta	Graph.h	/^		magenta=FL_MAGENTA, cyan=FL_CYAN, dark_red=FL_DARK_RED,$/;"	e	enum:Graph_lib::Color::Color_type
major	Graph.h	/^	int major() const { return w; }$/;"	f	struct:Graph_lib::Ellipse	typeref:typename:int
mark	Graph.h	/^	string mark;$/;"	m	struct:Graph_lib::Marked_polyline	typeref:typename:string
minor	Graph.h	/^	int minor() const { return h; }$/;"	f	struct:Graph_lib::Ellipse	typeref:typename:int
move	GUI.h	/^	virtual void move(int dx,int dy) { hide(); pw->position(loc.x+=dx, loc.y+=dy); show(); }$/;"	f	class:Graph_lib::Widget	typeref:typename:void
move	GUI.h	/^	void move(int dx, int dy)$/;"	f	struct:Graph_lib::Menu	typeref:typename:void
move	Graph.cpp	/^void Axis::move(int dx, int dy)$/;"	f	class:Graph_lib::Axis	typeref:typename:void
move	Graph.cpp	/^void Shape::move(int dx, int dy)$/;"	f	class:Graph_lib::Shape	typeref:typename:void
move	Graph.h	/^	void move(int dx,int dy) { Shape::move(dx,dy); p->draw(point(0).x,point(0).y); }$/;"	f	struct:Graph_lib::Image	typeref:typename:void
next	Simple_window.cpp	/^void Simple_window::next()$/;"	f	class:Simple_window	typeref:typename:void
next_button	Simple_window.h	/^	Button next_button;$/;"	m	struct:Simple_window	typeref:typename:Button
no_fill	Graph.h	/^	bool no_fill;$/;"	m	struct:Graph_lib::Fill	typeref:typename:bool
none	Graph.h	/^	enum Encoding { none, jpg, gif, bmp, png};$/;"	e	enum:Graph_lib::Suffix::Encoding
notches	Graph.h	/^	Lines notches;$/;"	m	struct:Graph_lib::Axis	typeref:typename:Lines
number_of_points	Graph.h	/^	int number_of_points() const { return int(points.size()); }$/;"	f	class:Graph_lib::Shape	typeref:typename:int
offset	GUI.h	/^	int offset;$/;"	m	struct:Graph_lib::Menu	typeref:typename:int
operator !=	Point.h	/^inline bool operator!=(Point a, Point b) { return !(a==b); }$/;"	f	namespace:Graph_lib	typeref:typename:bool
operator +=	Point.h	/^	Point& operator+=(Point d) { x+=d.x; y+=d.y; return *this; }$/;"	f	struct:Graph_lib::Point	typeref:typename:Point &
operator ==	Point.h	/^inline bool operator==(Point a, Point b) { return a.x==b.x && a.y==b.y; }$/;"	f	namespace:Graph_lib	typeref:typename:bool
operator []	Graph.h	/^	T& operator[](int i) { return *v[i]; }$/;"	f	class:Graph_lib::Vector_ref	typeref:typename:T &
operator []	Graph.h	/^	const T& operator[](int i) const { return *v[i]; }$/;"	f	class:Graph_lib::Vector_ref	typeref:typename:const T &
own	GUI.h	/^	Window* own;	\/\/ every Widget belongs to a Window$/;"	m	class:Graph_lib::Widget	typeref:typename:Window *
owned	Graph.h	/^	vector<T*> owned;$/;"	m	class:Graph_lib::Vector_ref	typeref:typename:vector<T * >
p	Graph.h	/^	Fl_Image* p;$/;"	m	struct:Graph_lib::Image	typeref:typename:Fl_Image *
png	Graph.h	/^	enum Encoding { none, jpg, gif, bmp, png};$/;"	e	enum:Graph_lib::Suffix::Encoding
point	Graph.h	/^	Point point(int i) const { return points[i]; }$/;"	f	class:Graph_lib::Shape	typeref:typename:Point
points	Graph.h	/^	vector<Point> points;	\/\/ not used by all shapes$/;"	m	class:Graph_lib::Shape	typeref:typename:vector<Point>
push_back	Graph.h	/^	void push_back(T& s) { v.push_back(&s); }$/;"	f	class:Graph_lib::Vector_ref	typeref:typename:void
push_back	Graph.h	/^	void push_back(T* p) { v.push_back(p); owned.push_back(p); }$/;"	f	class:Graph_lib::Vector_ref	typeref:typename:void
put	GUI.cpp	/^void Out_box::put(const string& s)$/;"	f	class:Out_box	typeref:typename:void
put	GUI.cpp	/^void Out_box::put(int i)$/;"	f	class:Out_box	typeref:typename:void
put_on_top	Window.cpp	/^void Window::put_on_top(Shape& p) {$/;"	f	class:Graph_lib::Window	typeref:typename:void
pw	GUI.h	/^	Fl_Widget* pw;$/;"	m	class:Graph_lib::Widget	typeref:typename:Fl_Widget *
r	Graph.h	/^	int r;$/;"	m	struct:Graph_lib::Circle	typeref:typename:int
radius	Graph.h	/^	int radius() const { return r; }$/;"	f	struct:Graph_lib::Circle	typeref:typename:int
red	Graph.h	/^		red=FL_RED, blue=FL_BLUE, green=FL_GREEN,$/;"	e	enum:Graph_lib::Color::Color_type
reference_to	GUI.h	/^template<class W> W& reference_to(Address pw)$/;"	f	namespace:Graph_lib	typeref:typename:W &
resize	Window.h	/^	void resize(int ww, int hh) { w=ww, h=hh; size(ww,hh); }$/;"	f	class:Graph_lib::Window	typeref:typename:void
s	Graph.h	/^	int s;$/;"	m	struct:Graph_lib::Line_style	typeref:typename:int
screen	Graph.h	/^		screen=FL_SCREEN,$/;"	e	enum:Graph_lib::Font::Font_type
screen_bold	Graph.h	/^		screen_bold=FL_SCREEN_BOLD,$/;"	e	enum:Graph_lib::Font::Font_type
selection	GUI.h	/^	Vector_ref<Button> selection;$/;"	m	struct:Graph_lib::Menu	typeref:typename:Vector_ref<Button>
set_color	Graph.cpp	/^void Axis::set_color(Color c)$/;"	f	class:Graph_lib::Axis	typeref:typename:void
set_color	Graph.h	/^	void set_color(Color col) { lcolor = col; }$/;"	f	class:Graph_lib::Shape	typeref:typename:void
set_fill_color	Graph.h	/^	void set_fill_color(Color col) { fcolor = col; }$/;"	f	class:Graph_lib::Shape	typeref:typename:void
set_fill_color	Graph.h	/^	void set_fill_color(Color col) { fcolor = col; }$/;"	f	struct:Graph_lib::Fill	typeref:typename:void
set_font	Graph.h	/^	void set_font(Font f) { fnt = f; }$/;"	f	struct:Graph_lib::Text	typeref:typename:void
set_font_size	Graph.h	/^	void set_font_size(int s) { fnt_sz = s; }$/;"	f	struct:Graph_lib::Text	typeref:typename:void
set_label	Graph.h	/^	void set_label(const string& s) { lab = s; }$/;"	f	struct:Graph_lib::Text	typeref:typename:void
set_label	Window.h	/^	void set_label(const string& s) { label(s.c_str()); }$/;"	f	class:Graph_lib::Window	typeref:typename:void
set_major	Graph.h	/^	void set_major(int ww) { w=ww; }$/;"	f	struct:Graph_lib::Ellipse	typeref:typename:void
set_mask	Graph.h	/^	void set_mask(Point xy, int ww, int hh) { w=ww; h=hh; cx=xy.x; cy=xy.y; }$/;"	f	struct:Graph_lib::Image	typeref:typename:void
set_minor	Graph.h	/^	void set_minor(int hh) { h=hh; }$/;"	f	struct:Graph_lib::Ellipse	typeref:typename:void
set_point	Graph.h	/^	void set_point(int i, Point p) { points[i] = p; }$/;"	f	class:Graph_lib::Shape	typeref:typename:void
set_radius	Graph.h	/^	void set_radius(int rr) { r=rr; }$/;"	f	struct:Graph_lib::Circle	typeref:typename:void
set_style	Graph.h	/^	void set_style(Line_style sty) { ls = sty; }$/;"	f	class:Graph_lib::Shape	typeref:typename:void
set_visibility	Graph.h	/^	void set_visibility(Transparency vv) { v=vv; }$/;"	f	struct:Graph_lib::Color	typeref:typename:void
shapes	Window.h	/^	  vector<Shape*> shapes;	\/\/ shapes attached to window$/;"	m	class:Graph_lib::Window	typeref:typename:vector<Shape * >
show	GUI.h	/^	virtual void show() { pw->show(); }$/;"	f	class:Graph_lib::Widget	typeref:typename:void
show	GUI.h	/^	void show() { for (int i = 0; i<selection.size(); ++i) selection[i].show(); }$/;"	f	struct:Graph_lib::Menu	typeref:typename:void
size	Graph.h	/^	int size() const { return v.size(); }$/;"	f	class:Graph_lib::Vector_ref	typeref:typename:int
solid	Graph.h	/^		solid=FL_SOLID,				\/\/ -------$/;"	e	enum:Graph_lib::Line_style::Line_style_type
style	Graph.h	/^	Line_style style() const { return ls; }$/;"	f	class:Graph_lib::Shape	typeref:typename:Line_style
style	Graph.h	/^	int style() const { return s; }$/;"	f	struct:Graph_lib::Line_style	typeref:typename:int
suffix_map	Graph.cpp	/^std::map<string,Suffix::Encoding> suffix_map;$/;"	v	namespace:Graph_lib	typeref:typename:std::map<string,Suffix::Encoding>
symbol	Graph.h	/^		symbol=FL_SYMBOL,$/;"	e	enum:Graph_lib::Font::Font_type
times	Graph.h	/^		times=FL_TIMES,$/;"	e	enum:Graph_lib::Font::Font_type
times_bold	Graph.h	/^		times_bold=FL_TIMES_BOLD,$/;"	e	enum:Graph_lib::Font::Font_type
times_bold_italic	Graph.h	/^		times_bold_italic=FL_TIMES_BOLD_ITALIC,$/;"	e	enum:Graph_lib::Font::Font_type
times_italic	Graph.h	/^		times_italic=FL_TIMES_ITALIC,$/;"	e	enum:Graph_lib::Font::Font_type
v	Graph.h	/^	unsigned char v;	\/\/ 0 or 1 for now$/;"	m	struct:Graph_lib::Color	typeref:typename:unsigned char
v	Graph.h	/^	vector<T*> v;$/;"	m	class:Graph_lib::Vector_ref	typeref:typename:vector<T * >
vertical	GUI.h	/^	enum Kind { horizontal, vertical };$/;"	e	enum:Graph_lib::Menu::Kind
visibility	Graph.h	/^	char visibility() const { return v; }$/;"	f	struct:Graph_lib::Color	typeref:typename:char
visible	Graph.h	/^	enum Transparency { invisible = 0, visible=255 };$/;"	e	enum:Graph_lib::Color::Transparency
w	Graph.h	/^	int w,h,cx,cy; \/\/ define "masking box" within image relative to position (cx,cy)$/;"	m	struct:Graph_lib::Image	typeref:typename:int
w	Graph.h	/^	int w;			\/\/ width$/;"	m	struct:Graph_lib::Rectangle	typeref:typename:int
w	Graph.h	/^	int w;$/;"	m	struct:Graph_lib::Ellipse	typeref:typename:int
w	Graph.h	/^	int w;$/;"	m	struct:Graph_lib::Line_style	typeref:typename:int
w	Window.h	/^	  int w,h;					\/\/ window size$/;"	m	class:Graph_lib::Window	typeref:typename:int
wait_for_button	Simple_window.cpp	/^void Simple_window::wait_for_button()$/;"	f	class:Simple_window	typeref:typename:void
white	Graph.h	/^		yellow=FL_YELLOW, white=FL_WHITE, black=FL_BLACK,$/;"	e	enum:Graph_lib::Color::Color_type
width	GUI.h	/^	int width;$/;"	m	class:Graph_lib::Widget	typeref:typename:int
width	Graph.h	/^	int width() const { return w; }$/;"	f	struct:Graph_lib::Line_style	typeref:typename:int
width	Graph.h	/^	int width() const { return w; }$/;"	f	struct:Graph_lib::Rectangle	typeref:typename:int
x	Graph.h	/^	enum Orientation { x, y, z };$/;"	e	enum:Graph_lib::Axis::Orientation
x	Point.h	/^	int x,y;$/;"	m	struct:Graph_lib::Point	typeref:typename:int
x_max	Window.h	/^	int x_max() const { return w; }$/;"	f	class:Graph_lib::Window	typeref:typename:int
x_max	Window.h	/^inline int x_max() { return Fl::w(); }	\/\/ width of screen in pixels$/;"	f	namespace:Graph_lib	typeref:typename:int
y	Graph.h	/^	enum Orientation { x, y, z };$/;"	e	enum:Graph_lib::Axis::Orientation
y	Point.h	/^	int x,y;$/;"	m	struct:Graph_lib::Point	typeref:typename:int
y_max	Window.h	/^	int y_max() const { return h; }$/;"	f	class:Graph_lib::Window	typeref:typename:int
y_max	Window.h	/^inline int y_max() { return Fl::h(); }	\/\/ height of screen in pixels$/;"	f	namespace:Graph_lib	typeref:typename:int
yellow	Graph.h	/^		yellow=FL_YELLOW, white=FL_WHITE, black=FL_BLACK,$/;"	e	enum:Graph_lib::Color::Color_type
z	Graph.h	/^	enum Orientation { x, y, z };$/;"	e	enum:Graph_lib::Axis::Orientation
zapf_dingbats	Graph.h	/^		zapf_dingbats=FL_ZAPF_DINGBATS$/;"	e	enum:Graph_lib::Font::Font_type
~Image	Graph.h	/^	~Image() { delete p; }$/;"	f	struct:Graph_lib::Image
~Shape	Graph.h	/^	virtual ~Shape() { }$/;"	f	class:Graph_lib::Shape
~Vector_ref	Graph.h	/^	~Vector_ref() { for (int i=0; i<owned.size(); ++i) delete owned[i]; }$/;"	f	class:Graph_lib::Vector_ref
~Widget	GUI.h	/^	virtual ~Widget() { }$/;"	f	class:Graph_lib::Widget
~Window	Window.h	/^	virtual ~Window() { }$/;"	f	class:Graph_lib::Window
